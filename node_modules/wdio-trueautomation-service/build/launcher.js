'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fetch = require('node-fetch');
var which = require('which');
var fs = require('fs');
var childProcess = require('child_process');
var isPortReachable = require('is-port-reachable');

var TrueautomationLauncher = function () {
  function TrueautomationLauncher() {
    _classCallCheck(this, TrueautomationLauncher);

    this.trueautomationLog = null;
    this.trueautomationPort = null;
  }

  _createClass(TrueautomationLauncher, [{
    key: 'onPrepare',
    value: function onPrepare(config, capabilities) {
      var _this = this;

      this.trueautomationLog = config.trueautomationLog || 'log/trueautomation-' + Date.now() + '.log';

      var args = [];

      if (config.remote) {
        var hostname = config.hostname ? config.hostname : config.host;

        var updateCapabilities = function updateCapabilities(cap) {
          var taRemoteUrl = 'http://' + hostname + ':' + config.port;
          cap.taRemoteUrl = taRemoteUrl.replace(/\/$/, '');
        };

        if (Array.isArray(capabilities)) {
          capabilities.forEach(function (capability) {
            return updateCapabilities(capability);
          });
        } else {
          updateCapabilities(capabilities);
        }

        config.hostname = '127.0.0.1';
        config.port = 9151;

        args.push('--remote');
      }

      this.trueautomationPort = config.port || 3000;
      args.push('--port', this.trueautomationPort);

      if (config.driver) {
        args.push('--driver', config.driver);

        if (config.driverVersion) {
          args.push('--driver-version', config.driverVersion);
        }
      }

      if (this.trueautomationLog) {
        args.push('--log-file', this.trueautomationLog);
      }

      var executable = config.trueautomationExecutable || process.env.TRUEAUTOMATION_EXEC || 'trueautomation';

      var resolvedExecutable = which.sync(executable, { nothrow: true });

      if (!resolvedExecutable) {
        console.error(executable + ' not found. Can not find TrueAutomation.IO client.');
        process.exit(-10);
      }

      if (!fs.existsSync('log')) {
        fs.mkdirSync('log');
      }

      console.log('Executing', resolvedExecutable, args.join(' '));
      var proc = childProcess.spawn(resolvedExecutable, args);

      proc.stdout.on('data', function (data) {
        console.log('trueautomation: ', data.toString());
      });

      proc.stderr.on('data', function (data) {
        console.error('trueautomation: ', data.toString());
      });

      proc.on('close', function (code) {
        console.log('trueautomation process exited with code ' + code);
      });

      proc.on('error', function (err) {
        console.log('Failed to start subprocess.', err);
      });

      return new Promise(function (resolve, reject) {
        var counter = 0;

        var checkPort = function checkPort() {
          isPortReachable(_this.trueautomationPort).then(function (isReachable) {
            if (isReachable) {
              resolve();
            } else {
              if (counter++ < 10) {
                setTimeout(checkPort, 2000);
              } else {
                console.error('Can not start TrueAutomation.IO service');
                reject(new Error('Can not start TrueAutomation.IO service'));
              }
            }
          });
        };

        checkPort();
      });
    }
  }, {
    key: 'onComplete',
    value: function onComplete() {
      return fetch('http://localhost:' + this.trueautomationPort + '/shutdown');
    }
  }]);

  return TrueautomationLauncher;
}();

exports.default = TrueautomationLauncher;
